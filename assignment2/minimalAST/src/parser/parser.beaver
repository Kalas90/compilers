%class "LangParser";
%package "lang.ast";

%embed {:
	static public class SyntaxError extends RuntimeException { public SyntaxError(String msg) {super(msg);}}
	// Disable syntax error recovery
	protected void recoverFromError(Symbol token, TokenStream in) {
		throw new SyntaxError("Cannot recover from the syntax error");
	}
:};

%terminals ID, INT, LPAR, RPAR, MUL, DIV, MOD, PLUS, MINUS, NEQ, EQ, GEQ, LEQ, GREATER, LESS, COMMA, INTW, LBR, RBR, RETURN, ASSIGN, IF, ELSE, WHILE, SEMI, COMMENT;

%typeof program = "Program";
%typeof program_component_list = "List";
%typeof program_component = "ProgramComponent";
%typeof comment = "ProgramComponent";
%typeof function_dec = "ProgramComponent";
%typeof param_list = "List";
%typeof stmt_list = "List";
%typeof stmt = "Stmt";
%typeof compound_stmt = "CompoundStmt";
%typeof if_stmt = "Stmt";
%typeof while_stmt = "Stmt";
%typeof assign_stmt = "Stmt";
%typeof function_stmt = "Stmt";
%typeof return_stmt = "Stmt";
%typeof decl_stmt = "Stmt";
%typeof opt_assign = "Opt";
%typeof expr = "Expr";
%typeof comp_expr = "Expr";
%typeof term = "Expr";
%typeof factor = "Expr";
%typeof add_sub_list = "List";
%typeof id_decl = "IdDecl";
%typeof id_use = "IdUse";
%typeof function_factor = "FunctionFactor";

%goal program;

program = program_component_list.a {: return new Program(a); :} ;

program_component_list =
	program_component.a {: return new List().add(a); :}
	| program_component_list.a program_component.b {: return a.add(b); :}
	;

program_component = 
	function_dec	
	| comment 	
	;

function_dec = id_decl.a LPAR param_list.b RPAR compound_stmt.c {: return new FunctionDec(a, b, c); :} ;

comment = COMMENT {: return new Comment(); :} ;

param_list = 
	id_decl.a {: return new List().add(a); :}
	| param_list.a COMMA id_decl.b {: return a.add(b); :}
	| /* epsilon */ {: return new List(); :}
	;

stmt_list =
	//stmt.a {: return new List().add(a); :}
	stmt_list.a stmt.b {: return a.add(b); :}
	| /* epsilon */ {: return new List(); :}
	;  

stmt =
	if_stmt
	| while_stmt
	| function_stmt
	| return_stmt
	| assign_stmt
	| decl_stmt
	;

compound_stmt = LBR stmt_list.a RBR {: return new CompoundStmt(a); :} ;

function_factor = id_use.a LPAR add_sub_list.b RPAR {: return new FunctionFactor(a, b); :} ;
function_stmt = function_factor.a SEMI {: return new FunctionStmt(a); :} ;

return_stmt = RETURN expr.a SEMI{: return new ReturnStmt(a); :} ;

assign_stmt = id_use.a ASSIGN expr.b SEMI {: return new AssignStmt(a, b); :} ;

decl_stmt = id_decl.a opt_assign.b SEMI {: return new DeclStmt(a, b); :} ;

opt_assign = /*epsilon*/ {: return new Opt(); :}
	    |ASSIGN expr.a {: return new Opt(a); :}
	    ;

if_stmt = IF LPAR comp_expr.a RPAR compound_stmt.b {: return new IfStmt(a, b, new CompoundStmt(new List())); :}
	| IF LPAR comp_expr.a RPAR compound_stmt.b ELSE compound_stmt.c {: return new IfStmt(a, b, c); :}
	;

while_stmt = WHILE LPAR comp_expr.a RPAR compound_stmt.b {: return new WhileStmt(a, b); :} ;

add_sub_list =
	expr.a {: return new List().add(a); :}
	| add_sub_list.a COMMA expr.b {: return a.add(b); :}
	| /* epsilon */ {: return new List(); :}
	;

comp_expr = expr.a EQ expr.b {: return new Equal(a, b); :}
	   |expr.a NEQ expr.b {: return new NEqual(a, b); :} 
	   |expr.a GREATER expr.b {: return new Greater(a, b); :} 
	   |expr.a LESS expr.b {: return new Less(a, b); :} 
	   |expr.a GEQ expr.b {: return new GreaterEqual(a, b); :} 
	   |expr.a LEQ expr.b {: return new LessEqual(a, b); :} 
	   ;

expr =
	expr.a PLUS term.b {: return new Add(a, b); :}
	|expr.a MINUS term.b {: return new Sub(a, b); :}
	|term 
	;

term =
	term.a MUL factor.b {: return new Mul(a, b); :}
	|term.a DIV factor.b {: return new Div(a, b); :}
	|term.a MOD factor.b {: return new Mod(a, b); :}
	|factor
	;

factor =
	id_use
	| int_use 
	| LPAR expr RPAR 
	| function_factor
	;


id_use = ID.id {: return new IdUse(id); :} ;
int_use = INT.i {: return new IntUse(i); :} ;
id_decl = INTW ID.id {: return new IdDecl(id); :} ;

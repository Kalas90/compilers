package lang.ast;

import beaver.*;
import java.util.ArrayList;

/**
 * This class is a LALR parser generated by
 * <a href="http://beaver.sourceforge.net">Beaver</a> v0.9.6.1
 * from the grammar specification "parser.beaver".
 */
public class LangParser extends Parser {
	static public class Terminals {
		static public final short EOF = 0;
		static public final short LPAR = 1;
		static public final short ID = 2;
		static public final short INT = 3;
		static public final short RPAR = 4;
		static public final short PLUS = 5;
		static public final short MINUS = 6;
		static public final short SEMI = 7;
		static public final short INTW = 8;
		static public final short LBR = 9;
		static public final short MUL = 10;
		static public final short DIV = 11;
		static public final short MOD = 12;
		static public final short ASSIGN = 13;
		static public final short COMMENT = 14;
		static public final short COMMA = 15;
		static public final short IF = 16;
		static public final short ELSE = 17;
		static public final short WHILE = 18;
		static public final short RBR = 19;
		static public final short RETURN = 20;
		static public final short EQ = 21;
		static public final short NEQ = 22;
		static public final short GREATER = 23;
		static public final short LESS = 24;
		static public final short GEQ = 25;
		static public final short LEQ = 26;

		static public final String[] NAMES = {
			"EOF",
			"LPAR",
			"ID",
			"INT",
			"RPAR",
			"PLUS",
			"MINUS",
			"SEMI",
			"INTW",
			"LBR",
			"MUL",
			"DIV",
			"MOD",
			"ASSIGN",
			"COMMENT",
			"COMMA",
			"IF",
			"ELSE",
			"WHILE",
			"RBR",
			"RETURN",
			"EQ",
			"NEQ",
			"GREATER",
			"LESS",
			"GEQ",
			"LEQ"
		};
	}

	static final ParsingTables PARSING_TABLES = new ParsingTables(
		"U9p5bSbF544KnhyUPe1X6L51H11rs5HcH5PnmttVSDyryUJ9aoSFwb$XnMXCF7Wmdamq9bw" +
		"CHkE#x$k2WeeiAeBRy#kQDrXWmzMU$EhxNhsgwgwgxXh0oSSIpCS8Z44Yah0S2V0ZOE82L2" +
		"6CAD8n3jMemG1aO206OJ0oCHmJCHbJCGqpJBi9R5UEFDClswgfjRFIXI3cy3vhK8GjvZwfy" +
		"77iU9kHpCJzMBc856GX3RCGma9hd7pBZxPycUKdMNwAvUiiFztoCos$oFBBBB$Q#0YzgvM8" +
		"Yl1vYx5UrsSpesHvQjQWXD4GhDFCA9IYGls$POv7FXNZpJWU6NbYCh5ec3osebnvP4M5yj2" +
		"APii3AugLRhpOylL$lRnX$mRvXdaOYhbydbLOWGLOYRLOYetIYGsSxIRaSiy3tD5HS4WXzx" +
		"NOn6xzSEvKAUjzVAVAE9zopgIIAvV5bSdcg3aOrjrk1FVUxLVGeyRsVluAU8zaxa3iFa7kl" +
		"izgaspvQhwv6HYhRsjVO$uF7rVmUVrctTpr2J4gCLz48h#p46l7QIQ5Qv#c$jyox94FwZXz" +
		"PsBHm1vHk4Vaz1kvPS2S5ttx9FO9crqByWI9CavYFfspy$DDI#RCWQrxOQvzv83hu$3oat9" +
		"IGQgj#ZgxdHUyZf8Cm4cZdY5NoJND1SWXSfWS8qV8SSrz82V8VerFYSWlwcboaforxd6UN5" +
		"1$ZjpeurdSUTucTyWZyfYy9Az88saYBQILj9CEFdSw2SRwEo4TfujqQbqg2o6$DKua0zHpV" +
		"WxNpidIU8Xg2idqUBvipl6rH$qUrLBL8hPhy9gZHz#0wa5LUzrgLOjTvPXjLYva#JhLYEek" +
		"ApUxr$rsz$Ci2rNhLTUeRbBTPhNDL6tkDSRsNl4Eox#p$4wF#xUh$knLlpKcyaj#oW$e9T#" +
		"5xu1ybW$I9gtI8f#aMJvsPr#JLztHVN97RiWpwdlodDmZj#MwoL#JkonloLMv8fVbfhn0Fv" +
		"VmdPGcungrvfqftsfqYNmnxgjqo6#Q6fwo3izWnvp3XLIN8dvX9SoMc3FCntFQuVUUGC3ps" +
		"4TW$XMy2BDT7h$yShQheA#ahw96sIVAkZAENSPpP3mrmlOHvYBC5L2z6DcDmpCumSBX6Hmd" +
		"mMWkoJV$OZxK$04f5YJX");

	static final Action RETURN3 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 3];
		}
	};

	static public class SyntaxError extends RuntimeException { public SyntaxError(String msg) {super(msg);}}
	// Disable syntax error recovery
	protected void recoverFromError(Symbol token, TokenStream in) {
		throw new SyntaxError("Cannot recover from the syntax error");
	}

	private final Action[] actions;

	public LangParser() {
		super(PARSING_TABLES);
		actions = new Action[] {
			new Action() {	// [0] program = program_component_list.a
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final List a = (List) _symbol_a.value;
					 return new Program(a);
				}
			},
			new Action() {	// [1] program_component_list = program_component.a
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final ProgramComponent a = (ProgramComponent) _symbol_a.value;
					 return new List().add(a);
				}
			},
			new Action() {	// [2] program_component_list = program_component_list.a program_component.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final List a = (List) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 2];
					final ProgramComponent b = (ProgramComponent) _symbol_b.value;
					 return a.add(b);
				}
			},
			Action.RETURN,	// [3] program_component = function_dec
			Action.RETURN,	// [4] program_component = comment
			new Action() {	// [5] function_dec = id_decl.a LPAR param_opt.b RPAR compound_stmt.c
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final IdDecl a = (IdDecl) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Opt b = (Opt) _symbol_b.value;
					final Symbol _symbol_c = _symbols[offset + 5];
					final CompoundStmt c = (CompoundStmt) _symbol_c.value;
					 return new FunctionDec(a, b, c);
				}
			},
			new Action() {	// [6] param_opt = 
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new Opt();
				}
			},
			new Action() {	// [7] param_opt = param.a
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Param a = (Param) _symbol_a.value;
					 return new Opt(a);
				}
			},
			new Action() {	// [8] param = id_decl.a param_list.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final IdDecl a = (IdDecl) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 2];
					final List b = (List) _symbol_b.value;
					 return new Param(a,b);
				}
			},
			new Action() {	// [9] comment = COMMENT
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new Comment();
				}
			},
			new Action() {	// [10] param_list = param_list.a COMMA id_decl.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final List a = (List) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final IdDecl b = (IdDecl) _symbol_b.value;
					 return a.add(b);
				}
			},
			new Action() {	// [11] param_list = 
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new List();
				}
			},
			new Action() {	// [12] stmt_list = stmt_list.a stmt.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final List a = (List) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 2];
					final Stmt b = (Stmt) _symbol_b.value;
					 return a.add(b);
				}
			},
			new Action() {	// [13] stmt_list = 
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new List();
				}
			},
			Action.RETURN,	// [14] stmt = if_stmt
			Action.RETURN,	// [15] stmt = while_stmt
			Action.RETURN,	// [16] stmt = function_stmt
			Action.RETURN,	// [17] stmt = return_stmt
			Action.RETURN,	// [18] stmt = assign_stmt
			Action.RETURN,	// [19] stmt = decl_stmt
			new Action() {	// [20] compound_stmt = LBR stmt_list.a RBR
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 2];
					final List a = (List) _symbol_a.value;
					 return new CompoundStmt(a);
				}
			},
			new Action() {	// [21] function_factor = id_use.a LPAR add_sub_list.b RPAR
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final IdUse a = (IdUse) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final List b = (List) _symbol_b.value;
					 return new FunctionFactor(a, b);
				}
			},
			new Action() {	// [22] function_stmt = function_factor.a SEMI
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final FunctionFactor a = (FunctionFactor) _symbol_a.value;
					 return new FunctionStmt(a);
				}
			},
			new Action() {	// [23] return_stmt = RETURN add_sub.a SEMI
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 2];
					final Expr a = (Expr) _symbol_a.value;
					 return new ReturnStmt(a);
				}
			},
			new Action() {	// [24] assign_stmt = id_use.a ASSIGN add_sub.b SEMI
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final IdUse a = (IdUse) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new AssignStmt(a, b);
				}
			},
			new Action() {	// [25] decl_stmt = id_decl.a opt_assign.b SEMI
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final IdDecl a = (IdDecl) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 2];
					final Opt b = (Opt) _symbol_b.value;
					 return new DeclStmt(a, b);
				}
			},
			new Action() {	// [26] opt_assign = 
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new Opt();
				}
			},
			new Action() {	// [27] opt_assign = ASSIGN add_sub.a
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 2];
					final Expr a = (Expr) _symbol_a.value;
					 return new Opt(a);
				}
			},
			new Action() {	// [28] if_stmt = IF LPAR comp_expr.a RPAR compound_stmt.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 3];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 5];
					final CompoundStmt b = (CompoundStmt) _symbol_b.value;
					 return new IfStmt(a, b, new CompoundStmt(new List()));
				}
			},
			new Action() {	// [29] if_stmt = IF LPAR comp_expr.a RPAR compound_stmt.b ELSE compound_stmt.c
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 3];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 5];
					final CompoundStmt b = (CompoundStmt) _symbol_b.value;
					final Symbol _symbol_c = _symbols[offset + 7];
					final CompoundStmt c = (CompoundStmt) _symbol_c.value;
					 return new IfStmt(a, b, c);
				}
			},
			new Action() {	// [30] while_stmt = WHILE LPAR comp_expr.a RPAR compound_stmt.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 3];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 5];
					final CompoundStmt b = (CompoundStmt) _symbol_b.value;
					 return new WhileStmt(a, b);
				}
			},
			new Action() {	// [31] add_sub_list = add_sub.a
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					 return new List().add(a);
				}
			},
			new Action() {	// [32] add_sub_list = add_sub_list.a COMMA add_sub.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final List a = (List) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return a.add(b);
				}
			},
			new Action() {	// [33] add_sub_list = 
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new List();
				}
			},
			new Action() {	// [34] comp_expr = add_sub.a EQ add_sub.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new Equal(a, b);
				}
			},
			new Action() {	// [35] comp_expr = add_sub.a NEQ add_sub.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new NEqual(a, b);
				}
			},
			new Action() {	// [36] comp_expr = add_sub.a GREATER add_sub.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new Greater(a, b);
				}
			},
			new Action() {	// [37] comp_expr = add_sub.a LESS add_sub.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new Less(a, b);
				}
			},
			new Action() {	// [38] comp_expr = add_sub.a GEQ add_sub.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new GreaterEqual(a, b);
				}
			},
			new Action() {	// [39] comp_expr = add_sub.a LEQ add_sub.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new LessEqual(a, b);
				}
			},
			new Action() {	// [40] add_sub = add_sub.a PLUS term.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new Add(a, b);
				}
			},
			new Action() {	// [41] add_sub = add_sub.a MINUS term.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new Sub(a, b);
				}
			},
			Action.RETURN,	// [42] add_sub = term
			new Action() {	// [43] term = term.a MUL factor.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new Mul(a, b);
				}
			},
			new Action() {	// [44] term = term.a DIV factor.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new Div(a, b);
				}
			},
			new Action() {	// [45] term = term.a MOD factor.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new Mod(a, b);
				}
			},
			Action.RETURN,	// [46] term = factor
			Action.RETURN,	// [47] factor = id_use
			Action.RETURN,	// [48] factor = int_use
			RETURN3,	// [49] factor = LPAR add_sub RPAR; returns 'RPAR' although none is marked
			Action.RETURN,	// [50] factor = function_factor
			new Action() {	// [51] id_use = ID.id
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol id = _symbols[offset + 1];
					 return new IdUse(id);
				}
			},
			new Action() {	// [52] int_use = INT.i
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol i = _symbols[offset + 1];
					 return new IntUse(i);
				}
			},
			new Action() {	// [53] id_decl = INTW ID.id
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol id = _symbols[offset + 2];
					 return new IdDecl(id);
				}
			}
		};
	}

	protected Symbol invokeReduceAction(int rule_num, int offset) {
		return actions[rule_num].reduce(_symbols, offset);
	}
}
